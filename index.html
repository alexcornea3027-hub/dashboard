<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VCB StockTeam — 3D Dashboard</title>

  <!-- Chart.js for quick 2D sparklines and numeric charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Three.js for 3D visuals -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root{
      --bg1:#fffdf8; --bg2:#fff6ee;
      --card: rgba(255,255,255,0.92);
      --muted:#6b7280; --accent:#ff7043; --accent-2:#ff8a65;
      --success:#16a34a; --danger:#ef4444;
    }
    .dark{
      --bg1:#071022; --bg2:#0d1824; --card: rgba(6,10,16,0.7); --muted:#cbd5e1;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background: linear-gradient(160deg,var(--bg1),var(--bg2)); color:#0f172a;}
    .wrap{max-width:1400px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 380px;gap:18px;align-items:start;}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;}
    .brand{font-weight:800;font-size:20px;}
    .meta{font-size:13px;color:var(--muted);}
    .controls{display:flex;gap:8px;align-items:center;}
    button{background:var(--card);border:0;padding:8px 12px;border-radius:10px;cursor:pointer;box-shadow:0 8px 28px rgba(10,10,10,0.06);font-weight:600;}
    .mainCard{background:transparent;border-radius:14px;padding:0;}
    .card{background:var(--card);border-radius:14px;padding:14px;box-shadow:0 12px 40px rgba(10,10,10,0.06);}
    /* layout inside left column */
    .topRow{display:flex;gap:12px;align-items:center;padding:12px;}
    .clock{flex:1;text-align:center;padding:8px;border-radius:12px;}
    .timeBig{font-size:56px;font-weight:800;}
    .dateSmall{font-size:14px;color:var(--muted);margin-top:6px;}
    .hourglass{width:96px;height:96px;display:flex;align-items:center;justify-content:center;border-radius:12px;font-size:42px;background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(255,255,255,0.85));box-shadow:0 6px 20px rgba(0,0,0,0.05);}
    .hg-rot { transform: rotate(360deg); transition: transform 700ms ease-in-out; }
    .threeCard{height:420px;border-radius:12px;overflow:hidden;display:flex;flex-direction:column;}
    .chartsGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px;}
    .smallCard{height:220px;padding:12px;display:flex;flex-direction:column;}
    .waterfall{height:150px;padding:12px;}
    /* right column */
    .rightCol{display:flex;flex-direction:column;gap:12px;}
    .summaryGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px;}
    .countsList{margin-top:10px;max-height:240px;overflow:auto;padding-right:6px;}
    .tasksList{margin-top:8px;max-height:300px;overflow:auto;padding-right:6px;}
    .taskItem{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;margin-bottom:8px;}
    .badge{padding:6px 10px;border-radius:999px;font-weight:700;font-size:12px;}
    .pending{background:rgba(255,152,72,0.12);color:#bf360c;}
    .completed{background:rgba(34,197,94,0.12);color:var(--success);}
    .footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px;}
    /* particles canvas */
    canvas.particles{position:fixed;left:0;top:0;pointer-events:none;z-index:0;opacity:0.16;}
    /* responsive */
    @media (max-width:1100px){
      .wrap{grid-template-columns:1fr; padding:10px;}
      .threeCard{height:380px;}
      .smallCard{height:200px;}
    }
  </style>
</head>
<body>
  <canvas class="particles" id="particles"></canvas>

  <div class="wrap">
    <div>
      <header>
        <div>
          <div class="brand">VCB StockTeam — 3D Dashboard</div>
          <div class="meta">Data source: <code>/data/dashboard.json</code></div>
        </div>
        <div class="controls">
          <button id="refreshBtn" title="Reload data">Refresh Data</button>
          <button id="themeBtn" title="Toggle theme">Light / Dark</button>
          <button id="fullBtn" title="Fullscreen">Fullscreen</button>
        </div>
      </header>

      <div class="card mainCard">
        <div class="topRow">
          <div class="clock card" style="flex:1;">
            <div id="time" class="timeBig">--:--</div>
            <div id="date" class="dateSmall">Loading date...</div>
          </div>

          <div class="hourglass" id="hourglass">
            <div id="hg" style="font-size:40px;">⏳</div>
            <div style="font-size:11px;color:var(--muted);margin-top:6px;text-align:center;">minute tick</div>
          </div>
        </div>

        <!-- 3D scene -->
        <div class="card threeCard" id="threeContainer">
          <!-- Three.js canvas will be injected here -->
          <div id="threeOverlay" style="position:absolute;right:14px;top:14px;z-index:3;">
            <div style="background:rgba(255,255,255,0.85);padding:6px 8px;border-radius:8px;font-weight:700;">Inventory 3D</div>
          </div>
        </div>

        <div class="chartsGrid">
          <div class="card smallCard">
            <strong>Daily Tasks — Completed vs Pending</strong>
            <canvas id="dailySpark" style="flex:1;margin-top:10px;"></canvas>
          </div>

          <div class="card smallCard">
            <strong>Weekly Tasks — Completed vs Pending</strong>
            <canvas id="weeklySpark" style="flex:1;margin-top:10px;"></canvas>
          </div>

          <div class="card smallCard">
            <strong>Weekly History (3D line + 2D spark)</strong>
            <div style="flex:1;display:flex;gap:8px;align-items:center;">
              <canvas id="historySpark" style="flex:1;height:120px;"></canvas>
            </div>
          </div>

          <div class="card smallCard">
            <strong>Waterfall / Cumulative (3D bars)</strong>
            <div style="flex:1;margin-top:8px;display:flex;align-items:center;justify-content:center;color:var(--muted);">Rotate scene with mouse</div>
          </div>
        </div>
      </div>
    </div>

    <aside class="rightCol">
      <div class="card">
        <strong>Summary</strong>
        <div class="summaryGrid">
          <div class="card" style="padding:12px;text-align:center;">
            <div style="font-size:12px;color:var(--muted)">Target</div>
            <div id="targetVal" style="font-size:22px;font-weight:800">-</div>
          </div>
          <div class="card" style="padding:12px;text-align:center;">
            <div style="font-size:12px;color:var(--muted)">Timestamp</div>
            <div id="timeStampVal" style="font-size:22px;font-weight:800">-</div>
          </div>
        </div>

        <div class="countsList" id="countsList"></div>
      </div>

      <div class="card">
        <strong>Daily Tasks</strong>
        <div class="tasksList" id="dailyList"></div>
      </div>

      <div class="card">
        <strong>Weekly Tasks</strong>
        <div class="tasksList" id="weeklyList"></div>
      </div>

      <div class="card">
        <strong>Notes</strong>
        <div style="margin-top:8px;color:var(--muted);font-size:13px;">
          • Light theme by default, toggle dark with the button.<br>
          • 3D visuals (inventory, waterfall, history) are built from the JSON data.<br>
          • Use <code>Refresh Data</code> after you update <code>/data/dashboard.json</code>.
        </div>
      </div>
    </aside>
  </div>

  <div class="footer">VCB StockTeam — 3D Dashboard • Place your <code>/data/dashboard.json</code> relative to this page</div>

  <script>
  /* ===================== Utilities & UI wiring ===================== */
  const el = id => document.getElementById(id);
  const isCompleted = s => s && String(s).toLowerCase().includes('completed');

  // sample fallback if dashboard.json not found
  const SAMPLE = {
    metadata:{ target:1193, timestamp:'13:13:04' },
    counting:[
      {"area":"MPR","qty":14622},{"area":"PB1","qty":4329},{"area":"PB2","qty":795},{"area":"PB3","qty":772},
      {"area":"PB4","qty":164},{"area":"PBSRES","qty":5197},{"area":"MP","qty":25612},{"area":"MIX","qty":33087},
      {"area":"MS","qty":21512},{"area":"MSX","qty":28798},{"area":"FM","qty":2308},{"area":"HP","qty":561},{"area":"Total:","qty":137369}
    ],
    dailyTasks:[
      {"name":"Aged stock report 7AM","status":"Completed"},{"name":"ADJUSTMENTS (Returns)","status":"Not started"}
    ],
    weeklyTasks:[{"name":"(Weekly) SLA","status":"Not started"},{"name":"(once a month) Shrinkage for Period","status":"Completed"}],
    history:[{"week":"W23","total":100},{"week":"W24","total":120},{"week":"W25","total":90}]
  };

  async function fetchData(){
    try {
      const r = await fetch('/data/dashboard.json', {cache:'no-store'});
      if(!r.ok) throw new Error('Not ok');
      return await r.json();
    } catch(e){
      console.warn('Could not load /data/dashboard.json — using sample', e);
      return SAMPLE;
    }
  }

  function fillMetadata(data){
    el('targetVal').textContent = data.metadata?.target ?? '-';
    el('timeStampVal').textContent = data.metadata?.timestamp ?? '-';
  }

  function fillCounts(data){
    const list = el('countsList');
    list.innerHTML = '';
    (data.counting||[]).forEach(c=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.padding='8px 6px'; row.style.borderBottom='1px solid rgba(0,0,0,0.04)';
      row.innerHTML = `<div style="font-weight:700">${c.area}</div><div style="font-weight:800">${c.qty}</div>`;
      list.appendChild(row);
    });
  }

  function fillTasks(data){
    const dlist = el('dailyList'); dlist.innerHTML='';
    (data.dailyTasks||[]).forEach(t=>{
      const it = document.createElement('div'); it.className='taskItem';
      it.style.background = isCompleted(t.status) ? 'rgba(34,197,94,0.06)' : 'rgba(255,152,72,0.04)';
      it.innerHTML = `<div><div style="font-weight:700">${t.name}</div><div style="font-size:12px;color:var(--muted)">${t.status||''}</div></div>
                      <div class="badge ${isCompleted(t.status)?'completed':'pending'}">${isCompleted(t.status)?'Completed':'Pending'}</div>`;
      dlist.appendChild(it);
    });

    const wlist = el('weeklyList'); wlist.innerHTML='';
    (data.weeklyTasks||[]).forEach(t=>{
      const it = document.createElement('div'); it.className='taskItem';
      it.style.background = isCompleted(t.status) ? 'rgba(34,197,94,0.06)' : 'rgba(255,152,72,0.04)';
      it.innerHTML = `<div><div style="font-weight:700">${t.name}</div><div style="font-size:12px;color:var(--muted)">${t.status||''}</div></div>
                      <div class="badge ${isCompleted(t.status)?'completed':'pending'}">${isCompleted(t.status)?'Completed':'Pending'}</div>`;
      wlist.appendChild(it);
    });
  }

  /* ============== Chart.js sparklines for numeric clarity ============== */
  let dailyChart, weeklyChart, historyChart;
  function renderSparklines(data){
    const colors = ['#ff8a65','#ff7043','#ff5722','#ffa726','#ffd54f','#ffb74d'];
    const dailyCompleted = (data.dailyTasks||[]).filter(t=>isCompleted(t.status)).length;
    const dailyPending = (data.dailyTasks||[]).length - dailyCompleted;
    const weeklyCompleted = (data.weeklyTasks||[]).filter(t=>isCompleted(t.status)).length;
    const weeklyPending = (data.weeklyTasks||[]).length - weeklyCompleted;
    const historyLabels = (data.history||[]).map(h=>h.week||'');
    const historyValues = (data.history||[]).map(h=>Number(h.total||0));

    const dctx = el('dailySpark').getContext('2d');
    if(dailyChart) dailyChart.destroy();
    dailyChart = new Chart(dctx, {
      type:'bar',
      data:{labels:['Completed','Pending'], datasets:[{label:'Daily',data:[dailyCompleted,dailyPending],backgroundColor:[colors[4],colors[1]]}]},
      options:{plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,precision:0}}}
    });

    const wctx = el('weeklySpark').getContext('2d');
    if(weeklyChart) weeklyChart.destroy();
    weeklyChart = new Chart(wctx, {
      type:'bar',
      data:{labels:['Completed','Pending'], datasets:[{label:'Weekly',data:[weeklyCompleted,weeklyPending],backgroundColor:[colors[3],colors[2]]}]},
      options:{plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,precision:0}}}
    });

    const hctx = el('historySpark').getContext('2d');
    if(historyChart) historyChart.destroy();
    historyChart = new Chart(hctx, {
      type:'line',
      data:{labels:historyLabels, datasets:[{label:'Weekly total',data:historyValues,fill:true,tension:0.3,backgroundColor:'rgba(255,138,101,0.12)',borderColor:colors[0],pointRadius:3}]},
      options:{plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}
    });
  }

  /* ===================== Three.js 3D scene ===================== */
  let scene, camera, renderer, controls;
  let inventoryGroup, waterfallGroup, historyGroup;
  const threeContainer = el('threeContainer');

  function initThree(){
    // clear previous renderer if exists
    const existing = threeContainer.querySelector('canvas');
    if(existing){ existing.remove(); renderer && renderer.dispose && renderer.dispose(); }

    // scene & camera
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // we'll composite with CSS card visually
    camera = new THREE.PerspectiveCamera(40, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
    camera.position.set(0, 30, 60);

    // lights
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(50, 80, 50);
    scene.add(dir);
    const hemi = new THREE.HemisphereLight(0xffffee, 0x333333, 0.15);
    scene.add(hemi);

    // renderer
    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.position = 'relative';
    threeContainer.appendChild(renderer.domElement);

    // controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.autoRotate = false;
    controls.minDistance = 20; controls.maxDistance = 200;
    controls.target.set(0,6,0);

    // groups
    inventoryGroup = new THREE.Group(); scene.add(inventoryGroup);
    waterfallGroup = new THREE.Group(); scene.add(waterfallGroup);
    historyGroup = new THREE.Group(); scene.add(historyGroup);

    // small ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(250,250), new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.02}));
    ground.rotation.x = -Math.PI/2; ground.position.y = -0.1; scene.add(ground);

    window.addEventListener('resize', onThreeResize);
    animate();
  }

  function onThreeResize(){
    if(!renderer) return;
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
    camera.aspect = threeContainer.clientWidth / threeContainer.clientHeight;
    camera.updateProjectionMatrix();
  }

  function animate(){
    requestAnimationFrame(animate);
    controls && controls.update();
    // subtle group animation
    if(inventoryGroup) inventoryGroup.rotation.y += 0.002;
    renderer && renderer.render(scene, camera);
  }

  // Utility for creating a sector (pie slice) extruded in 3D
  function createPieSector(innerR, outerR, startAngle, endAngle, height, material){
    // build shape for sector
    const shape = new THREE.Shape();
    const segs = 64;
    const step = (endAngle - startAngle) / segs;
    // outer arc
    for(let i=0;i<=segs;i++){
      const a = startAngle + step * i;
      const x = Math.cos(a) * outerR;
      const y = Math.sin(a) * outerR;
      if(i===0) shape.moveTo(x,y); else shape.lineTo(x,y);
    }
    // inner arc (reverse)
    for(let i=segs;i>=0;i--){
      const a = startAngle + step * i;
      const x = Math.cos(a) * innerR;
      const y = Math.sin(a) * innerR;
      shape.lineTo(x,y);
    }
    const extrudeSettings = { depth: height, bevelEnabled:false };
    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    // center pivot at middle of depth
    geometry.translate(0,0,-height/2);
    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  // build 3D inventory pie from data.counting (exclude Total:)
  function buildInventory3D(counting){
    // clear
    inventoryGroup.clear();
    const arr = (counting||[]).filter(c=>c.area && c.area!=='Total:');
    const total = arr.reduce((s,x)=>s + Number(x.qty||0), 0) || 1;
    const colors = [0xff8a65,0xff7043,0xff5722,0xffb074,0xffccbc,0xffd54f,0xffb74d,0xffa726,0xff8f00,0xff6f00];

    let currentAngle = -Math.PI/2; // start at top
    const innerR = 8, outerR = 14, height=6;
    arr.forEach((seg,i)=>{
      const v = Number(seg.qty||0);
      const angle = (v/total) * Math.PI * 2;
      const material = new THREE.MeshStandardMaterial({color:colors[i%colors.length], metalness:0.2, roughness:0.6});
      const mesh = createPieSector(innerR, outerR, currentAngle, currentAngle + angle, height, material);
      // small separation outward
      const midAngle = currentAngle + angle/2;
      mesh.position.x = Math.cos(midAngle) * 0.6;
      mesh.position.z = Math.sin(midAngle) * 0.6;
      // label as text sprite (simple)
      inventoryGroup.add(mesh);
      currentAngle += angle;
    });

    // add center ring (visual)
    const ringMat = new THREE.MeshStandardMaterial({color:0xffffff,metalness:0.1,roughness:0.9,opacity:0.95,transparent:true});
    const center = new THREE.Mesh(new THREE.CylinderGeometry(innerR-0.6,innerR-0.6,6,64), ringMat);
    center.rotation.x = Math.PI/2;
    center.position.y = 0;
    inventoryGroup.add(center);

    inventoryGroup.position.set(-6, 2, 0);
  }

  // build waterfall as stacked 3D bars
  function buildWaterfall3D(counting){
    waterfallGroup.clear();
    const arr = (counting||[]).filter(c=>c.area && c.area!=='Total:');
    const colors = [0xff8a65,0xff7043,0xff5722,0xffb074,0xffccbc,0xffd54f,0xffb74d,0xffa726,0xff8f00,0xff6f00];
    // scale heights reasonably
    const maxQty = Math.max(...arr.map(a=>Number(a.qty||0)), 1);
    const scale = 28 / Math.sqrt(maxQty); // gentle scaling
    let x = -30;
    arr.forEach((a,i)=>{
      const qty = Number(a.qty||0);
      const height = Math.max(1, Math.sqrt(qty) * 1.5);
      const geo = new THREE.BoxGeometry(4, height, 6);
      const mat = new THREE.MeshStandardMaterial({color:colors[i%colors.length], metalness:0.2, roughness:0.5});
      const m = new THREE.Mesh(geo, mat);
      m.position.set(x, height/2 - 1, -18 + i*1.2);
      waterfallGroup.add(m);
      // label (simple sprite-like)
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font='20px Arial'; ctx.fillText(a.area,8,28);
      const tex = new THREE.CanvasTexture(canvas);
      const spriteMat = new THREE.SpriteMaterial({map:tex});
      const sprite = new THREE.Sprite(spriteMat);
      sprite.scale.set(6,1.5,1);
      sprite.position.set(x, -0.8, -18 + i*1.2);
      waterfallGroup.add(sprite);
      x += 6;
    });

    waterfallGroup.position.set(0, 2, 8);
  }

  // build history 3D as elevated polyline tube
  function buildHistory3D(history){
    historyGroup.clear();
    const arr = (history||[]).map(h=>({week:h.week||'', total:Number(h.total||0)}));
    if(arr.length===0) return;
    const max = Math.max(...arr.map(x=>x.total),1);
    // create points
    const gap = 8;
    const points = arr.map((p,i)=> new THREE.Vector3(-((arr.length-1)*gap)/2 + i*gap, (p.total/max)*18, 0));
    // create line geometry
    const curve = new THREE.CatmullRomCurve3(points);
    const tube = new THREE.TubeGeometry(curve, 64, 0.6, 8, false);
    const mat = new THREE.MeshStandardMaterial({color:0xff8a65,metalness:0.2,roughness:0.5});
    const mesh = new THREE.Mesh(tube, mat);
    historyGroup.add(mesh);
    // points as spheres and labels
    points.forEach((pt,i)=>{
      const s = new THREE.Mesh(new THREE.SphereGeometry(0.9, 12, 12), new THREE.MeshStandardMaterial({color:0xff7043}));
      s.position.copy(pt);
      historyGroup.add(s);
      const canvas = document.createElement('canvas'); canvas.width=200; canvas.height=60;
      const ctx = canvas.getContext('2d'); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.font='18px Arial'; ctx.fillText(arr[i].week + ' : ' + arr[i].total,8,28);
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(10,2.5,1); sprite.position.set(pt.x, pt.y + 2.4, pt.z);
      historyGroup.add(sprite);
    });
    historyGroup.position.set(20, 0, -6);
  }

  /* ===================== Particles background ===================== */
  (function particlesBackground(){
    const canvas = document.getElementById('particles');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    let w=canvas.width=window.innerWidth, h=canvas.height=window.innerHeight;
    let parts=[];
    function resize(){ w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight; parts=[]; for(let i=0;i<110;i++){ parts.push({x:Math.random()*w,y:Math.random()*h,r:1+Math.random()*2.5,vx:(Math.random()-0.5)*0.3,vy:(Math.random()-0.5)*0.3,alpha:0.06+Math.random()*0.6}); }}; resize();
    function draw(){ ctx.clearRect(0,0,w,h); for(const p of parts){ p.x+=p.vx; p.y+=p.vy; if(p.x<0) p.x=w; if(p.x>w) p.x=0; if(p.y<0) p.y=h; if(p.y>h) p.y=0; ctx.beginPath(); ctx.globalAlpha = p.alpha; ctx.fillStyle = '#ffffff'; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); } requestAnimationFrame(draw); }
    window.addEventListener('resize', resize);
    draw();
  })();

  /* ===================== Clock & hourglass ===================== */
  function updateTime(){
    const now = new Date();
    el('time').textContent = now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    el('date').textContent = now.toLocaleDateString();
  }
  updateTime();
  // schedule precise minute tick
  const msToNextMinute = (60 - new Date().getSeconds())*1000 - new Date().getMilliseconds();
  setTimeout(()=>{ updateTime(); rotateHG(); setInterval(()=>{ updateTime(); rotateHG(); }, 60*1000); }, msToNextMinute);

  function rotateHG(){
    const hg = el('hg'); if(!hg) return;
    hg.classList.remove('hg-rot'); void hg.offsetWidth; hg.classList.add('hg-rot');
  }

  /* ===================== Main load logic ===================== */
  async function buildAll(){
    const data = await fetchData();
    fillMetadata(data);
    fillCounts(data);
    fillTasks(data);
    renderSparklines(data);

    // init three if not
    if(!scene) initThree();

    // build 3D objects from data
    buildInventory3D(data.counting || []);
    buildWaterfall3D(data.counting || []);
    buildHistory3D(data.history || []);
  }

  // initial build
  buildAll();

  // UI actions
  el('refreshBtn').addEventListener('click', ()=>{ buildAll(); });
  el('themeBtn').addEventListener('click', ()=>{ document.documentElement.classList.toggle('dark'); });
  el('fullBtn').addEventListener('click', async ()=>{ try{ if(!document.fullscreenElement) await document.documentElement.requestFullscreen(); else await document.exitFullscreen(); }catch(e){console.warn(e);} });

  // expose simple globals
  window.refreshDashboard = buildAll;
  window.toggleTheme = () => document.documentElement.classList.toggle('dark');

  </script>
</body>
</html>
